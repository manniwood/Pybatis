<!DOCTYPE html>
<html>
<head><title>Pybatis</title></head>
<body>
<p>brought to you by Cystems Technology</p>
<p>written by Manni Wood, mwood a t cystems-tech.com, based on
Clinton Begin's original idea in <a href="http://ibatis.apache.org">iBATIS</a>.</p>
<h1>Pybatis</h1>
<h2>Overview</h2>
<p>Pybatis is three things combined: Python's DB API + templates + convenience
methods. Pybatis uses a templating engine to bring dynamic features to SQL in the same
way templating engines are often used to bring dynamic features to HTML. Pybatis
also provides convenience methods around Python's DB API for exucuting the SQL
produced by the templating engine.</p>
<p>Let's dive in with a code example. Say you want to select two columns, ID
and NAME, from
a table in your database to show to users of your application. But let's say
that sometimes you'd optionally like to show a third column, COLOUR, too.</p>
<p>Say your Python code stores
user input in a dict called form_values, and that if
 form_values["SHOW_COLOUR"] contains the string "true", you'll show
the COLOUR column in your SQL select results.</p>
<p>Not using Pybatis, a regular Python DB API implementation might look 
like this:</p>
<pre>
import psycopg2
conn = psycopg2.connect('user=theuser dbname=petstoredb')
curs = conn.cursor()
sql = '''
   select id as "ID",
'''
show_colour = form_values.get("SHOW_COLOUR") != None and  == "true":
if show_colour != None and show_colour == "true":
    sql += '''
    colour as "COLOUR",
    ''''
sql += '''
     name as "NAME"
     from pets
'''
results = curs.execute(sql)
</pre>
<p>It's not pretty, and not particularly easy to maintain. Here's how
you'd do the same thing in Pybatis:</p>
<pre>
import psycopg2
import psycopg2.extras
import pybatis
import pybatis.psycopg2_jinja2

conn = psycopg2.connect('user=theuser dbname=petstoredb')
SQL_MAP = pybatis.psycopg2_jinja2.SQLMap(conn, '/petstore-app/pybatis')
results = SQL_MAP.select_commit(inline='''
   select id      as "ID",
          {% if SHOW_COLOUR is not_empty and SHOW_COLOR == 'true' %}
          colour  as "COLOUR",
          {% endif %}
          name    as "NAME"
     from pets
''', map=form_values)
</pre>
<p>That's a bit tidier, but the SQL code is still embedded in
your Python. Some people would prefer to have the sql template
code in its own file, much the same way we keep our html template
code in separate files.</p>
<p>And you can: put the SQL template code in a file named
/petstore-app/pybatis/select_pets.sql with the following
contents:</p>
<pre>
   select id      as "ID",
          {% if SHOW_COLOUR is not_empty and SHOW_COLOR == 'true' %}
          colour  as "COLOUR",
          {% endif %}
          name    as "NAME"
     from pets
</pre>
<p>and then your calling code would look more like this:</p>
<pre>
import psycopg2
import psycopg2.extras
import pybatis
import pybatis.psycopg2_jinja2

conn = psycopg2.connect('user=theuser dbname=petstoredb')
SQL_MAP = pybatis.psycopg2_jinja2.SQLMap(conn, '/petstore-app/pybatis')

results = SQL_MAP.select_commit(file='select_pets.sql', map=form_values)
</pre>
<p>That's the essential idea of Pybatis. Now, the details.</p>

<h2>Using Pybatis</h2>
<h3>Configuring a SQL mapper</h3>
<p>The first thing you need to do is configure a SQL mapper
in the flavour of your database and templating engine. For now, 
Pybatis only supports the psycopg2 driver for PostgreSQL, and
the <a href="http://jinja.pocoo.org/2/">Jinja2</a> templating engine.
So right now, the choice of which mapper to use is easy; there's only
one. :-)</p>
<pre>
import psycopg2
import psycopg2.extras
import pybatis
import pybatis.psycopg2_jinja2

conn = psycopg2.connect('user=theuser dbname=petstoredb')
SQL_MAP = pybatis.psycopg2_jinja2.SQLMap(conn, '/petstore-app/pybatis')
</pre>
<p>Already, there are a few things to note. First, Pybatis needs to be handed
a database connection. Pybatis does not manage database connections directly,
and most certainly does not do connection pooling. There are plenty of connection
poolers out there, and I felt no need to write one myself.</p>
<p>(This would, however, be a good time to point out that often you don't need
a database connection pooler. For instance, in a web application on Apache
using the pre-fork MPM and mod_wsgi, each Apache process contains its own Python 
interpreter, and, in a framework like Django, its own connection to the database.
This eliminates the need for connection pooling.)</p>
<p>Please also note that the second argument to the SQLMap constructor is a location
in your filesystem for where you keep your SQL templates. Using the example
setting above, if you call 
<code>SQL_MAP.select_commit(file='select_pets.sql')</code>, the file argument will
get translated to '/petstore-app/pybatis/select_pets.sql'. (Note how Pybatis
does the right thing and inserts the slash between the config dir and the
file name.)</p>
<p>You can have as many sql mappers as you want, but each one will need its own
database connection. For a web app, it's usually best to have one sql map per
Python interpreter. In an environment like Django, where each Python interpreter
answers one web request at a time, having one sql map uses the least resources
and has no resource contention issues.</p>

XXXXX START HERE
<h3>Using a SQL mapper</h3>
</p>Now is a good time for an
example.</p>
<p>Let's say your pet store database contains the following table:</p>
<pre>
create sequence pet_ids start 1;
create table pets (
    id     bigint constraint "Pet id must be unique." primary key not null,
    name   varchar(50) not null,
    colour varchar(30) not null);
</pre>
<p>Let's say you have a web application where you sometimes want to show the colour
of a pet, and other times not. You have a web form that lets the user decide.
Let's say your form values are in a dict named form_values, and the form
field is form_values["SHOW_COLOUR"], and will contain the string "true" (because
all form values are delivered as strings) if we want to
show the color when we select pets from the database.</p>
<p>You could make a file called /petstore-app/pybatis/select_pets.sql with the following
contents:</p>
<pre>
   select id      as "ID",
          {% if SHOW_COLOUR is not_empty and SHOW_COLOR == 'true' %}
          colour  as "COLOUR",
          {% endif %}
          name    as "NAME"
     from pets
</pre>
<p>(For you Jinja users, please note that the test not_empty is added to the global list of Jinja
tests by pybatis.psycopg2.SQLMap when it is instantiated.)</p>
<p>And, from within your Python code, you would call the sql query like so:</p>
<pre>
results = SQL_MAP.select_commit(file='select_pets.sql', map=form_values)
</pre>
<p>Of course, an easier way to do the same thing would be to use Pybatis'
inline option:</p>
<pre>
results = SQL_MAP.select_commit(inline='''
   select id      as "ID",
          {% if SHOW_COLOUR is not_empty and SHOW_COLOR == 'true' %}
          colour  as "COLOUR",
          {% endif %}
          name    as "NAME"
     from pets
''', map=form_values)
</pre>
<p>This prompts the question: with inlining, why would you ever store your
SQL templates in separate files? One reasonable answer is if you want to use the same SQL template in
more that one location in your Python source code. Being able to store your SQL templates
in files starts to make a lot of sense. Also, sometimes a SQL statement just gets so long
that it increases the readability of the Python by moving the SQL out to its own file.</p>
<p>In the above example, the results of our sql statement have been put in a variable
called results. Results is simply a list of dicts that can be iterated through, like so:</p>
<pre>
# print all of the IDs
if results == None:
    print "No results found."
else:
    for db_row in results
        print("%(ID)i" % db_row)
</pre>
<p>Some things to note:</p>
<p>If there are no results for your query, None will be returned,
so you should always check for None.</p>
<p>In your SQL, always name your columns in your result set so that
you will know which key names to use for the dicts that get returned.
(And remember that they are case-sensitive!)</p>
<p>Your database's DB API implementation will determine the return
types of all columns. In our example, psycopg2 automatically gives us the 
ID field (which we had declared type bigint in PostgreSQL)
as a Python int; hence the "i" in our string formatter in our sample Python code
above.</p>
<p>Don't forget that you can control the return types of columns leveraging
your database's ability to do so:</p>
<pre>
   select cast(id as text) as "ID",
          {% if SHOW_COLOUR is not_empty and SHOW_COLOR == 'true' %}
          colour           as "COLOUR",
          {% endif %}
          name             as "NAME"
     from pets
</pre>
<pre>
results = SQL_MAP.select_commit(file='select_pets.sql', map=form_values)
# print all of the IDs as strings
if results == None:
    print "No results found."
else:
    for db_row in results
        print("%(ID)s" % db_row)
</pre>
<p>This is not a Pybatis trick; this is standard SQL. (It <em>is</em> 
an example of how Pybatis
gets out of your way and lets you use a cast in your SQL statement. It's
also an example of how psycopg2 auto-detects return types and tries
to pick a Python equivalent: in this case, translating PostgreSQL text
to a Python string.)
</p>
<p>
TODO:
link to Jinja and earlier mention that familiarity with Jinja is essential
how to feed in variables
recommended casting of fed-in variables
security
returning one row to a dict
returning one col of one row to a scalar
calling stored procs
transactions
exceptions
tips and tricks, like "where 1 = 1"
</p>













<h2>Origins</h2>
<p>Pybatis is based on , 
a SQL mapping library that I used
on many Java projects.</p>
<p>When I switched from Java to Python, I wanted to bring iBATIS with me.
There was no Python version, so I decided to write one myself. Pybatis
retains what I consider to be the soul of iBATIS, though I have stripped
it down to only what I think are iBATIS' essentials. I have also traded 
iBATIS' xml template language for the 
<a href="http://jinja.pocoo.org/2/">Jinja2</a> templating</p> system.
Familiarity with Jinja2 is therefore a must to use Pybatis
to its full potential.</p>
<h2>Philosophy</h2>
<p>This section can safely be skipped, unless you are
curious as to what it is I like about the iBATIS way of
thinking, and what motivated by port/design of Pybatis.</p>
<h3>ORM is the Vietnam of Computer Science</h3>
<p>Ted Neward's now-famous 
<a href="http://blogs.tedneward.com/2006/06/26/The+Vietnam+Of+Computer+Science.aspx">
blog entry likening object relational mapping to the Vietnam of computer science</a>
is a must read if you want to know why libraries like iBATIS and
Pybatis exist. Pybatis is the answer to the gripe "There must
be a better way." There is!</p>
<h3>Writing SQL is Fun</h3>
<p>Pybatis expects you to <em>want</em> to write
your own SQL. Coders want to write code. SQL is code. Developers
who do not want to write SQL make about as much sense as
developers who don't want to write C or Java or Python or
whatever application language they are using.</p>
<h3>Portable SQL is Highly Overrated</h3>
<p>I am strongly biased towards leveraging the strengths
of any SQL implementation. Not only does Pybatis refuse
to abstract away your database under a gooey layer of ORM,
it lets you directly leverage your database's unique
feature set. There <em>is</em> a reason why
you chose your database over another, isn't there? Then
take advantage of it!</p>
<h3>Dynamic SQL is Not a Compilation Problem; it is a Templating Problem</h3>
<p>Pybatis allows you to dynamically generate SQL,
essentially enhancing SQL with if/else and looping
constructs. This is similar to other templating
problems, such as generating html or CSS on the fly.
It is decidedly NOT code generation as ORMs do it. Pybatis
uses the Jinja templating engine to dynamically generate SQL,
abandoning iBATIS' unfortunate use of xml to accomplish the
same task.</p>
<h3>Objects Suck</h3>
<p>You don't have to use Object Relational Mapping if you don't
use objects! Countless enterprise gurus will tell you to map
your SQL tables into Java Beans, condemning to you a hell of
always having to maintain and update a sea of getters and setters
every time you change your data model.</p>
<p>Here's an idea: how about mapping
your SQL result sets (not tables, actual result sets from carefully
crafted queries) into lists of dicts? That is the default behaviour
of Pybatis. Objects are bad. Data structures are good. (And yes,
I realise data structures are implemented as objects in most modern
languages, but hashes and lists pre-date OOP, if you take my point.)</p>
<h3>Lecture Over</h3>
<p>The above biases are what I loved about (read into?) iBATIS
and these biases live on in Pybatis.</p>



</body>
</html>

