<!DOCTYPE html>
<html>
<head><title>Pybatis</title></head>
<body>
<p>brought to you by Cystems Technology</p>
<p>written by Manni Wood, mwood a t cystems-tech.com, based on
Clinton Begin's original idea in <a href="http://ibatis.apache.org">iBATIS</a>.</p>
<h1>Pybatis</h1>
<h2>Overview</h2>
<p>Pybatis is three things combined: Python's DB API + templates + convenience
methods. Pybatis uses a templating engine to bring dynamic features to SQL in the same
way templating engines are often used to bring dynamic features to HTML. Pybatis
also provides convenience methods around Python's DB API for exucuting the SQL
produced by the templating engine.</p>
<p>Let's dive in with a code example. Say you want to select two columns, ID
and NAME, from
a table in your database to show to users of your application. But let's say
that sometimes you'd optionally like to show a third column, COLOUR, too.</p>
<p>Say your Python code stores
user input in a dict called form_values, and that if
 form_values["SHOW_COLOUR"] contains the string "true", you'll show
the COLOUR column in your SQL select results.</p>
<p>Not using Pybatis, a regular Python DB API implementation might look 
like this:</p>
<pre>
import psycopg2
conn = psycopg2.connect('user=theuser dbname=petstoredb')
curs = conn.cursor()
sql = '''
   select id as "ID",
'''
show_colour = form_values.get("SHOW_COLOUR") != None and  == "true":
if show_colour != None and show_colour == "true":
    sql += '''
    colour as "COLOUR",
    ''''
sql += '''
     name as "NAME"
     from pets
'''
results = curs.execute(sql)
</pre>
<p>It's not pretty, and not particularly easy to maintain. Here's how
you'd do the same thing in Pybatis:</p>
<pre>
import psycopg2
import psycopg2.extras
import pybatis
import pybatis.psycopg2_jinja2

conn = psycopg2.connect('user=theuser dbname=petstoredb')
SQL_MAP = pybatis.psycopg2_jinja2.SQLMap(conn, '/petstore-app/pybatis')
results = SQL_MAP.select_commit(inline='''
   select id      as "ID",
          {% if SHOW_COLOUR is not_empty and SHOW_COLOR == 'true' %}
          colour  as "COLOUR",
          {% endif %}
          name    as "NAME"
     from pets
''', map=form_values)
</pre>
<p>That's a bit tidier, but the SQL code is still embedded in
your Python. Some people would prefer to have the sql template
code in its own file, much the same way we keep our html template
code in separate files.</p>
<p>And you can: put the SQL template code in a file named
/petstore-app/pybatis/select_pets.sql with the following
contents:</p>
<pre>
   select id      as "ID",
          {% if SHOW_COLOUR is not_empty and SHOW_COLOR == 'true' %}
          colour  as "COLOUR",
          {% endif %}
          name    as "NAME"
     from pets
</pre>
<p>and then your calling code would look more like this:</p>
<pre>
import psycopg2
import psycopg2.extras
import pybatis
import pybatis.psycopg2_jinja2

conn = psycopg2.connect('user=theuser dbname=petstoredb')
SQL_MAP = pybatis.psycopg2_jinja2.SQLMap(conn, '/petstore-app/pybatis')

results = SQL_MAP.select_commit(file='select_pets.sql', map=form_values)
</pre>
<p>That's the essential idea of Pybatis. Now, the details.</p>

<h2>Using Pybatis</h2>
<h3>Configuring a SQL mapper</h3>
<p>The first thing you need to do is configure a SQL mapper once
and use it throughout your application. Each SQL mapper implementation
is named after the 
DB API driver it supports and templating engine it uses. For now, 
Pybatis only supports the psycopg2 driver for PostgreSQL, and
the <a href="http://jinja.pocoo.org/2/">Jinja2</a> templating engine.
So right now, the choice of which mapper to use is easy; there's only
one. :-)</p>
<pre>
import psycopg2
import psycopg2.extras
import pybatis
import pybatis.psycopg2_jinja2

conn = psycopg2.connect('user=theuser dbname=petstoredb')
SQL_MAP = pybatis.psycopg2_jinja2.SQLMap(conn, '/petstore-app/pybatis')
</pre>
<p>Already, there are a few things to note. First, Pybatis needs to be handed
a database connection. Pybatis does not create its own database connections,
and most certainly does not provide connection pooling. There are plenty of connection
poolers out there, and I felt no need to write one myself.</p>
<p>This would, however, be a good time to point out that often you don't need
a database connection pooler. For instance, in a desktop web application with
only one connection to the database, no connection pooling is necessary. You create
your one application to the database and hand it to the one SQL mapper you
will use throughout the application.</p>
<p>In a web application, you may need to figure out a way to hand connections
from a connection pool to your SQL mapper. Do note, however, that on Apache
using the pre-fork MPM and mod_wsgi, each Apache process contains its own Python 
interpreter, and, in a framework like Django, its own connection to the database.
This eliminates the need for connection pooling, because each Python interpreter
has only one connection to the database anyway. This architecture solves a lot
of problems.</p>
<p>Please also note that the second argument to the SQLMap constructor is a location
in your filesystem for where you keep your SQL templates. Using the example
setting above, if you call 
<code>SQL_MAP.select_commit(file='select_pets.sql')</code>, the file argument will
get translated to '/petstore-app/pybatis/select_pets.sql'. (Note how Pybatis
does the right thing and inserts the slash between the config dir and the
file name.)</p>
<p>You can have as many SQL mappers as you want in your application, 
but each one will need its own
database connection. You can usually get away with one SQL mapper
per Python interpreter.</p>

<h3>Controlling results</h3>
<p>Pybatis' select statements return a list of dicts. The key names
for each dict match the column names from the sql statements. As a matter
of style, it is best to explicitly name your return columns so that
you know what your keys will be:</p>
<pre>
results = SQL_MAP.select_commit(inline='''
   select id      as "ID",
          colour  as "COLOUR",
          name    as "NAME"
     from pets
 order by "ID"
''')
# print all ids
for row in results:
    print "%(ID)i" % row
</pre>
<h4>Return Types</h4>
<p>Pybatis lets the underlying DB API driver decide what the return
types will be for each column. If you want to control the return
types, use the casting capabilities of your SQL implementation. So,
if our pets table is defined as</p>
<pre>
create table pets (
    id bigint constraint "Pet ID must be unique." primary key not null,
    colour varchar(50) not null,
    name varchar(50) not null
);
</pre>
<p>but you wanted to select the ID column as an integer, you could
do this:
<pre>
results = SQL_MAP.select_commit(inline='''
   select cast(id as text) as "ID"
     from pets
 order by "ID"
''')
# print all ids
for row in results:
    print "%(ID)s" % row  # now ID is a string, not an integer
</pre>
<h4>Return Amounts</h4>
<p>Generally, you should control return amounts from your
SQL code:</p>
<pre>
   select id as "ID"
     from pets
    limit 10
</pre>
<p>However, sometimes you only want to return one row, or even
one row with one column, and it would be a bit silly to return a
a list of dicts.</p>
<p>For instance, let's say this only returns one row:</p>
<pre>
select id as "ID",
       colour as "COLOUR",
       name as "NAME"
  from pets
 where id = cast(%(ID)s as bigint)
</pre>
<p>It would be a bit silly to return a list of dicts; you'd
rather just get a dict. Well, you can, with the "ret" argument:</p>
<pre>
pet = SQL_MAP.select_commit(
    ret=pybatis.RETURN_FIRST_ROW,
    inline='''
   select id      as "ID",
          colour  as "COLOUR",
          name    as "NAME"
     from pets
 where id = cast(%(ID)s as bigint)
''')
# print the pet's NAME
print "%(NAME)s" % pet
</pre>
<p>And, of course, sometimes you want to return just one scalar.
You can do that too:</p>
<pre>
count = SQL_MAP.select_commit(
    ret=pybatis.RETURN_FIRST_DATUM,
    inline='''
   select count(*) as "COUNT"
     from pets
 order by "ID"
''')
# print the pet's NAME
print "number of pets: %i" % count
</pre>
<h4>Input Types</h4>
<p>In our examples above, you'll notice that we did our inputs
as:</p>
<pre>
 where id = cast(%(ID)s as bigint)
</pre>
<p>Essentially, all we are doing is leveraging the underlying
DB API implementation. In the case of Psycopg, the DB API implementation
for PostgreSQL, the "%(somekey)s" form is used, and that's why you
see it in the examples.</p>
<p><strong>IMPORTANT:</strong> It's important to know that the
Jinja templating is performed firs, and <em>then</em> the DB API
handles the %(blah)s variables. This is important to know, because
with DB API handling the variables, correct escaping is done on the variables
to prevent SQL injection attacks. If you need to have the Jinja template
engine put in variables instead, use Jinja's {{ blah }} format instead,
but NOTE that proper SQL escaping will not be done! One possible case
where you might want to do such a thing:</p>
<pre>
select id as "ID"
  from {{ table }}
 where id = cast(%(ID)s as bigint)
</pre>
<p>But if you don't fully understand (and protect against)
the danger of the above code example, never use {{ var }}
to get variables, but, instead, use %(var)s.</p>
<p>Finally note that in</p>
<pre>
 where id = cast(%(ID)s as bigint)
</pre>
<p>I explicitly cast the input value to match the column
type of the table I'm querying. Instead of relying on the DB API
to cast my input to the correct value, I find explicit casting
is a good habit to get into when dealing with inputs (in addition
to all the other error correction/detection!).</p>


<h3>Inserts and Updates</h3>
<p>These work as expected, except you use the SQL map's execute*
methods instead of the SQL map's select* methods.</p>
<pre>
        mt_config.SQL_MAP.execute_commit(inline='''
        insert into pets
                    (id,
                     colour,
                     name)
             values (cast(%(ID)s as bigint),
                     %(COLOUR)s,
                     %(NAME)s)
                ''', map=form_values, render=False)
</pre>
<p>An update:</p>
<pre>
        mt_config.SQL_MAP.execute_commit(inline='''
        update pets
           set colour = %(COLOUR)s
         where id = cast(%(ID)s as bigint)
                ''', map=form_values, render=False)

</pre>
<h3>Small Performance Enhancement</h3>
<p>Note in our insert and update examples that we
do not actually have any Jinja templating code
in our examples&mdash;just DB API stuff. If you
know that you don't need any template processing,
you can turn it off for individual method calls
by adding render=False to the method call,
as we have done in the insert and update examples.</p>

<h3>Stored Procedures</h3>

<h3>Transactions</h3>

<h3>Exception Handling</h3>

<h3>Debugging</h3>

XXXXX START HERE

<p>Some things to note:</p>
<p>If there are no results for your query, None will be returned,
so you should always check for None.</p>
<p>In your SQL, always name your columns in your result set so that
you will know which key names to use for the dicts that get returned.
(And remember that they are case-sensitive!)</p>
<p>Your database's DB API implementation will determine the return
types of all columns. In our example, psycopg2 automatically gives us the 
ID field (which we had declared type bigint in PostgreSQL)
as a Python int; hence the "i" in our string formatter in our sample Python code
above.</p>
<p>Don't forget that you can control the return types of columns leveraging
your database's ability to do so:</p>
<pre>
   select cast(id as text) as "ID",
          {% if SHOW_COLOUR is not_empty and SHOW_COLOR == 'true' %}
          colour           as "COLOUR",
          {% endif %}
          name             as "NAME"
     from pets
</pre>
<pre>
results = SQL_MAP.select_commit(file='select_pets.sql', map=form_values)
# print all of the IDs as strings
if results == None:
    print "No results found."
else:
    for db_row in results
        print("%(ID)s" % db_row)
</pre>
<p>This is not a Pybatis trick; this is standard SQL. (It <em>is</em> 
an example of how Pybatis
gets out of your way and lets you use a cast in your SQL statement. It's
also an example of how psycopg2 auto-detects return types and tries
to pick a Python equivalent: in this case, translating PostgreSQL text
to a Python string.)
</p>
<p>
TODO:
link to Jinja and earlier mention that familiarity with Jinja is essential
how to feed in variables
recommended casting of fed-in variables
security
returning one row to a dict
returning one col of one row to a scalar
calling stored procs
transactions
exceptions
tips and tricks, like "where 1 = 1"
</p>













<h2>Origins</h2>
<p>Pybatis is based on , 
a SQL mapping library that I used
on many Java projects.</p>
<p>When I switched from Java to Python, I wanted to bring iBATIS with me.
There was no Python version, so I decided to write one myself. Pybatis
retains what I consider to be the soul of iBATIS, though I have stripped
it down to only what I think are iBATIS' essentials. I have also traded 
iBATIS' xml template language for the 
<a href="http://jinja.pocoo.org/2/">Jinja2</a> templating</p> system.
Familiarity with Jinja2 is therefore a must to use Pybatis
to its full potential.</p>
<h2>Philosophy</h2>
<p>This section can safely be skipped, unless you are
curious as to what it is I like about the iBATIS way of
thinking, and what motivated by port/design of Pybatis.</p>
<h3>ORM is the Vietnam of Computer Science</h3>
<p>Ted Neward's now-famous 
<a href="http://blogs.tedneward.com/2006/06/26/The+Vietnam+Of+Computer+Science.aspx">
blog entry likening object relational mapping to the Vietnam of computer science</a>
is a must read if you want to know why libraries like iBATIS and
Pybatis exist. Pybatis is the answer to the gripe "There must
be a better way." There is!</p>
<h3>Writing SQL is Fun</h3>
<p>Pybatis expects you to <em>want</em> to write
your own SQL. Coders want to write code. SQL is code. Developers
who do not want to write SQL make about as much sense as
developers who don't want to write C or Java or Python or
whatever application language they are using.</p>
<h3>Portable SQL is Highly Overrated</h3>
<p>I am strongly biased towards leveraging the strengths
of any SQL implementation. Not only does Pybatis refuse
to abstract away your database under a gooey layer of ORM,
it lets you directly leverage your database's unique
feature set. There <em>is</em> a reason why
you chose your database over another, isn't there? Then
take advantage of it!</p>
<h3>Dynamic SQL is Not a Compilation Problem; it is a Templating Problem</h3>
<p>Pybatis allows you to dynamically generate SQL,
essentially enhancing SQL with if/else and looping
constructs. This is similar to other templating
problems, such as generating html or CSS on the fly.
It is decidedly NOT code generation as ORMs do it. Pybatis
uses the Jinja templating engine to dynamically generate SQL,
abandoning iBATIS' unfortunate use of xml to accomplish the
same task.</p>
<h3>Objects Suck</h3>
<p>You don't have to use Object Relational Mapping if you don't
use objects! Countless enterprise gurus will tell you to map
your SQL tables into Java Beans, condemning to you a hell of
always having to maintain and update a sea of getters and setters
every time you change your data model.</p>
<p>Here's an idea: how about mapping
your SQL result sets (not tables, actual result sets from carefully
crafted queries) into lists of dicts? That is the default behaviour
of Pybatis. Objects are bad. Data structures are good. (And yes,
I realise data structures are implemented as objects in most modern
languages, but hashes and lists pre-date OOP, if you take my point.)</p>
<h3>Lecture Over</h3>
<p>The above biases are what I loved about (read into?) iBATIS
and these biases live on in Pybatis.</p>



</body>
</html>

